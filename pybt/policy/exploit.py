"""Exploit policies.
"""

import logging
import random

from copy import copy
from math import floor, ceil

class Truncation:
    """Truncate-based selection.

    This does not really truncate the population, but it does use a truncated
    view of the population to make a decision about whether or not to exploit
    an existing member.

    # Arguments
        upper: fraction of population to consider the upper crust.
        lower: fraction of population to consider the bottom tier.
    """

    def __init__(self, upper=.20, lower=.20):
        self._logger = logging.getLogger(__name__)

        self._upper = upper
        self._lower = lower

    def __call__(self, member, members):
        sorted_members = sorted(members, key=lambda x: x._p)

        if len(members) == 0:
            return member
        if len(members) == 1:
            if member._p >= sorted_members[0]._p:
                return member
            else:
                return copy(sorted_members[0])

        top_index = min(floor(len(members) * (1-self._upper)), len(members)-1)
        bottom_index = ceil(len(members) * self._lower)

        top_cutoff = sorted_members[top_index]._p
        bottom_cutoff = sorted_members[bottom_index]._p

        self._logger.info('sorted {}'.format([str(m) for m in sorted_members]))
        if member._p < bottom_cutoff:
            self._logger.info('current member in bottom {}'.format(self._lower))
            self._logger.info('choosing from top {}, choosing from {}'.format(
                self._upper,
                [str(m) for m in \
                 sorted_members[floor(len(members) * (1-self._upper)):]]))

            top = sorted_members[floor(len(members) * (1-self._upper)):]
            return copy(random.choice(top))
        else:
            self._logger.info('current member not in bottom {}'.format(
                self._lower))

            return member

    def __str__(self):
        s = 'Truncation(upper={}, lower={})'.format(self._upper, self._lower)
        return s

